import * as vscode from 'vscode';
import { ProjectPlan, LayrConfig, PlanGenerator, AIProvider, AIProviderType } from './interfaces';
import { GeminiPlanGenerator } from './ai';
import { RuleBasedPlanGenerator } from './rules';
import { getAIProviderFactory } from './providers';
import { logger } from '../utils/logger';
import { AIProviderError } from '../utils/errors';

/**
 * Main planner class that orchestrates plan generation
 */
export class Planner {
  private aiProvider: AIProvider | null = null;
  private ruleGenerator: RuleBasedPlanGenerator;
  private config: LayrConfig;
  private aiModel!: string;

  constructor() {
    // ONLINE ONLY MODE: Disable rule-based generator
    this.ruleGenerator = new RuleBasedPlanGenerator();
    this.config = this.loadConfig();
    this.initializeAIProvider();
    
    logger.info('Planner: ONLINE ONLY MODE - Offline templates disabled');
  }

  /**
   * Generate a project plan from a natural language prompt - ONLINE ONLY MODE
   */
  async generatePlan(prompt: string): Promise<ProjectPlan> {
    logger.info('Planner.generatePlan: ONLINE ONLY MODE - Starting plan generation');
    
    // Force refresh config to ensure we have the latest API key
    this.refreshConfig();
    
    // Get user settings
    const config = vscode.workspace.getConfiguration('layr');
    const planSize = config.get<string>('planSize', 'Normal');
    const planType = config.get<string>('planType', 'SaaS');
    
    logger.debug('Planner.generatePlan: Plan size:', planSize);
    logger.debug('Planner.generatePlan: Plan type:', planType);
    logger.debug('Planner.generatePlan: AI provider exists:', !!this.aiProvider);
    logger.debug('Planner.generatePlan: AI provider type:', this.aiProvider?.type || 'none');
    
    // REQUIRE AI provider - no offline fallback allowed
    if (!this.aiProvider) {
      const errorMsg = `AI provider not initialized.

Please configure your AI provider:
1. Set up your configuration in VS Code Settings or .env file
2. Reload VS Code (Ctrl+R) to apply changes
3. Try creating a plan again

For help with setup:
- Documentation: https://github.com/manasdutta04/layr#setup
- Troubleshooting: https://github.com/manasdutta04/layr#troubleshooting`;
      logger.error('Planner.generatePlan:', errorMsg);
      vscode.window.showErrorMessage(errorMsg, 'Show Logs').then(selection => {
        if (selection === 'Show Logs') {
          logger.show();
        }
      });
      throw new AIProviderError('AI provider not initialized', 'none');
    }

    const isAvailable = await this.aiProvider.isAvailable();
    logger.debug('Planner.generatePlan: AI provider available:', isAvailable);
    
    if (!isAvailable) {
      const errorMsg = `AI provider is currently unavailable.

Please verify:
1. Your configuration is correct in VS Code Settings or .env file
2. Your internet connection is working
3. Your API credentials are valid

Next steps:
1. Check your configuration: https://github.com/manasdutta04/layr#setup
2. Reload VS Code (Ctrl+R) to refresh
3. Try again

If the issue persists:
- Visit: https://github.com/manasdutta04/layr/issues
- Check troubleshooting: https://github.com/manasdutta04/layr#troubleshooting`;
      
      logger.error('Planner.generatePlan:', errorMsg);
      vscode.window.showErrorMessage(errorMsg, 'Show Logs').then(selection => {
        if (selection === 'Show Logs') {
          logger.show();
        }
      });
      throw new AIProviderError('AI provider unavailable', this.aiProvider.name);
    }

    try {
      logger.info('Planner.generatePlan: Attempting AI plan generation with', this.aiProvider.name);
      const planMarkdown = await this.aiProvider.generatePlan(prompt, { planSize, planType });
      logger.info('Planner.generatePlan: AI plan generation successful');
      logger.debug('Planner.generatePlan: Raw response length:', planMarkdown.length);
      logger.debug('Planner.generatePlan: Raw response preview:', planMarkdown.substring(0, 200));
      
      // Return the Markdown directly wrapped in a simple ProjectPlan structure
      // The AI already generates perfect Markdown, no need to parse and reformat
      const plan: ProjectPlan = {
        title: 'AI Generated Plan',
        overview: planMarkdown, // Store the full markdown in overview
        requirements: [],
        fileStructure: [],
        nextSteps: [],
        generatedAt: new Date(),
        generatedBy: 'ai'
      };
      
      vscode.window.showInformationMessage(`Plan generated by Layr AI! ðŸ¤–`);
      return plan;
    } catch (error) {
      logger.error('Planner.generatePlan: AI plan generation failed:', error);
      
      let errorMessage = '';
      
      if (error instanceof AIProviderError) {
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = `Plan generation failed: ${error.message}

Troubleshooting:
1. Check your internet connection
2. Verify API key configuration: https://github.com/manasdutta04/layr#setup
3. Check ${this.aiProvider?.name || 'AI'} service status
4. Try again with a simpler project description

Need help? Visit: https://github.com/manasdutta04/layr/issues`;
      } else {
        errorMessage = `Unexpected error: ${String(error)}. Please try again or report at: https://github.com/manasdutta04/layr/issues`;
      }
      
      vscode.window.showErrorMessage(errorMessage, 'Show Logs').then(selection => {
        if (selection === 'Show Logs') {
          logger.show();
        }
      });
      throw error;
    }
  }

  /**
   * Convert a ProjectPlan to Markdown format
   */
  planToMarkdown(plan: ProjectPlan): string {
    // If the plan was generated by AI and contains markdown in overview, ensure watermark is present
    if (plan.generatedBy === 'ai' && plan.overview.includes('#')) {
      // Generate watermark with time and day
      const now = plan.generatedAt || new Date();
      const dayName = now.toLocaleDateString('en-US', { weekday: 'long' });
      const dateStr = now.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
      const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      const watermark = `*Generated by Layr on ${dayName}, ${dateStr} at ${timeStr}*`;
      
      // Check if watermark already exists in the content
      if (!plan.overview.includes('*Generated by Layr')) {
        // Prepend watermark if not present
        return `${watermark}\n\n---\n\n${plan.overview}`;
      }
      
      return plan.overview;
    }
    
    // Otherwise, use the old formatting (for rule-based plans)
    const markdown = [];
    
    // Header
    markdown.push(`# ${plan.title}`);
    markdown.push('');
    markdown.push(`*Generated by Layr on ${plan.generatedAt.toLocaleDateString()} at ${plan.generatedAt.toLocaleTimeString()}*`);
    markdown.push('');

    // Overview
    markdown.push('## Overview');
    markdown.push(plan.overview);
    markdown.push('');

    // Requirements
    markdown.push('## Requirements');
    plan.requirements.forEach(req => {
      markdown.push(`- ${req}`);
    });
    markdown.push('');

    // File Structure
    markdown.push('## File Structure');
    markdown.push('```');
    this.renderFileStructure(plan.fileStructure, markdown, 0);
    markdown.push('```');
    markdown.push('');

    // Next Steps
    markdown.push('## Next Steps');
    plan.nextSteps.forEach((step, index) => {
      const checkbox = step.completed ? '[x]' : '[ ]';
      const priority = step.priority === 'high' ? 'ðŸ”´' : step.priority === 'medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';
      const time = step.estimatedTime ? ` (${step.estimatedTime})` : '';
      markdown.push(`${index + 1}. ${checkbox} ${priority} ${step.description}${time}`);
      
      if (step.dependencies && step.dependencies.length > 0) {
        markdown.push(`   - *Depends on: ${step.dependencies.join(', ')}*`);
      }
    });
    markdown.push('');

    // Footer
    markdown.push('---');
    markdown.push('*Generated by Layr AI - Your AI-Powered Project Planning Assistant*');

    return markdown.join('\n');
  }

  /**
   * Refine a specific section of the plan
   */
  async refineSection(sectionContent: string, refinementPrompt: string, fullContext: string): Promise<string> {
    if (!this.aiProvider) {
      throw new AIProviderError('AI provider not initialized', 'none');
    }

    const isAvailable = await this.aiProvider.isAvailable();
    if (!isAvailable) {
      throw new AIProviderError('AI provider unavailable', this.aiProvider.name);
    }

    try {
      return await this.aiProvider.refineSection(sectionContent, refinementPrompt, fullContext);
    } catch (error) {
      logger.error('Planner.refineSection error:', error);
      throw error;
    }
  }

  /**
   * Refresh configuration and reinitialize AI provider
   */
  refreshConfig(): void {
    this.config = this.loadConfig();
    this.initializeAIProvider();
  }

  /**
   * Debug method to check if AI provider is available
   */
  async isAIAvailable(): Promise<boolean> {
    return this.aiProvider !== null && await this.aiProvider.isAvailable();
  }

  /**
   * Debug method to test the API key
   */
  async testAPIKey(): Promise<{ success: boolean; error?: string }> {
    if (!this.aiProvider) {
      return { success: false, error: 'AI provider not initialized' };
    }
    try {
      const isValid = await this.aiProvider.validateApiKey(this.getApiKeyForProvider());
      return { success: isValid };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  private loadConfig(): LayrConfig {
    // Hardcoded to use Groq - no user configuration needed!
    this.aiModel = 'llama-3.3-70b-versatile';
    const aiProvider: AIProviderType = 'groq';
    
    // Only read from environment variable, not from VS Code settings
    const groqApiKey = process.env.GROQ_API_KEY || '';
    
    logger.debug('Layr Config Debug:', {
      selectedModel: this.aiModel,
      determinedProvider: aiProvider,
      apiKey: groqApiKey ? '***configured***' : 'using embedded key'
    });
    
    return {
      aiProvider,
      groq: {
        apiKey: groqApiKey,
        model: this.aiModel as any
      }
    };
  }

  private initializeAIProvider(): void {
    logger.debug('Planner.initializeAIProvider: Starting AI provider initialization');
    logger.debug('Planner.initializeAIProvider: Selected model:', this.aiModel);
    logger.debug('Planner.initializeAIProvider: Using Groq provider (pre-configured)');
    
    try {
      const factory = getAIProviderFactory();
      
      // Always use Groq - pre-configured for users
      const providerConfig = {
        apiKey: this.config.groq?.apiKey || '',
        model: this.aiModel
      };
      
      logger.debug('Planner.initializeAIProvider: Provider config:', { 
        model: this.aiModel,
        apiKey: providerConfig.apiKey ? '[CONFIGURED]' : '[USING EMBEDDED KEY]' 
      });
      
      this.aiProvider = factory.createProvider('groq', providerConfig);
      logger.info('Planner.initializeAIProvider: Groq provider created successfully');
    } catch (error) {
      logger.error('Planner.initializeAIProvider: Failed to create Groq provider:', error);
      this.aiProvider = null;
    }
  }

  private getApiKeyForProvider(): string {
    // Only Groq is supported - pre-configured
    return this.config.groq?.apiKey || '';
  }

  private parseAIPlan(planText: string): ProjectPlan {
    logger.debug('Planner.parseAIPlan: Starting to parse AI response');
    logger.debug('Planner.parseAIPlan: Response length:', planText.length);
    
    try {
      // Try multiple JSON extraction methods
      let jsonText = '';
      
      // Method 1: Look for JSON between ```json and ``` markers
      const codeBlockMatch = planText.match(/```json\s*([\s\S]*?)\s*```/);
      if (codeBlockMatch) {
        jsonText = codeBlockMatch[1].trim();
        logger.debug('Planner.parseAIPlan: Found JSON in code block');
      } else {
        // Method 2: Look for JSON between ``` and ``` markers (without json specifier)
        const genericCodeBlockMatch = planText.match(/```\s*([\s\S]*?)\s*```/);
        if (genericCodeBlockMatch) {
          const potentialJson = genericCodeBlockMatch[1].trim();
          if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {
            jsonText = potentialJson;
            logger.debug('Planner.parseAIPlan: Found JSON in generic code block');
          }
        }
        
        if (!jsonText) {
          // Method 3: Look for JSON object starting with { and ending with }
          const jsonMatch = planText.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            jsonText = jsonMatch[0];
            logger.debug('Planner.parseAIPlan: Found JSON object');
          } else {
            // Method 4: Try to parse the entire response as JSON
            try {
              JSON.parse(planText.trim());
              jsonText = planText.trim();
              logger.debug('Planner.parseAIPlan: Entire response is valid JSON');
            } catch {
              logger.warn('Planner.parseAIPlan: No valid JSON found in response');
              logger.debug('Planner.parseAIPlan: Full response for debugging:', planText);
              throw new AIProviderError('Invalid response format from AI service - no JSON found', this.aiProvider?.name || 'unknown');
            }
          }
        }
      }

      logger.debug('Planner.parseAIPlan: Extracted JSON preview:', jsonText.substring(0, 200) + (jsonText.length > 200 ? '...' : ''));

      // Try to parse JSON with error handling and repair
      let planData;
      try {
        planData = JSON.parse(jsonText);
        logger.debug('Planner.parseAIPlan: Successfully parsed JSON');
      } catch (parseError) {
        logger.warn('Planner.parseAIPlan: JSON parse error:', parseError);
        logger.info('Planner.parseAIPlan: Attempting to repair JSON...');
        
        // Try to repair common JSON issues
        let repairedJson = jsonText;
        
        // Fix trailing commas in arrays and objects
        repairedJson = repairedJson.replace(/,(\s*[}\]])/g, '$1');
        
        // Fix missing commas between array elements
        repairedJson = repairedJson.replace(/}(\s*){/g, '},$1{');
        repairedJson = repairedJson.replace(/](\s*)\[/g, '],$1[');
        
        // Fix missing quotes around property names
        repairedJson = repairedJson.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
        
        // Try parsing the repaired JSON
        try {
          planData = JSON.parse(repairedJson);
          logger.info('Planner.parseAIPlan: Successfully repaired and parsed JSON');
        } catch (repairError) {
          logger.error('Planner.parseAIPlan: Failed to repair JSON:', repairError);
          logger.debug('Planner.parseAIPlan: Original JSON for debugging:', jsonText);
          throw new AIProviderError('Failed to parse AI response as JSON', this.aiProvider?.name || 'unknown');
        }
      }
      
      // Validate and transform the response
      const plan: ProjectPlan = {
        title: planData.title || 'Generated Project Plan',
        overview: planData.overview || 'No overview provided',
        requirements: Array.isArray(planData.requirements) ? planData.requirements : [],
        fileStructure: this.validateFileStructure(planData.fileStructure || []),
        nextSteps: this.validateNextSteps(planData.nextSteps || []),
        generatedAt: new Date(),
        generatedBy: 'ai'
      };

      logger.info('Planner.parseAIPlan: Successfully created ProjectPlan object');
      return plan;
    } catch (error) {
      logger.error('Planner.parseAIPlan: Failed to parse AI plan:', error);
      // Fallback to a basic plan structure
      return {
        title: 'AI Generated Plan',
        overview: planText.substring(0, 200) + '...',
        requirements: ['Review and refine the generated plan'],
        fileStructure: [],
        nextSteps: [
          {
            id: 'review',
            description: 'Review the AI-generated plan and make necessary adjustments',
            completed: false,
            priority: 'high' as const,
            estimatedTime: '30 minutes',
            dependencies: []
          }
        ],
        generatedAt: new Date(),
        generatedBy: 'ai' as const
      };
    }
  }

  private validateFileStructure(items: any[]): any[] {
    if (!Array.isArray(items)) return [];
    
    return items.map(item => ({
      name: item.name || 'unnamed',
      type: item.type === 'directory' ? 'directory' : 'file',
      description: item.description || '',
      children: item.children ? this.validateFileStructure(item.children) : []
    }));
  }

  private validateNextSteps(steps: any[]): any[] {
    if (!Array.isArray(steps)) return [];
    
    return steps.map((step, index) => ({
      id: step.id || `step-${index}`,
      description: step.description || 'No description',
      completed: false,
      priority: ['high', 'medium', 'low'].includes(step.priority) ? step.priority : 'medium',
      estimatedTime: step.estimatedTime || 'Unknown',
      dependencies: Array.isArray(step.dependencies) ? step.dependencies : []
    }));
  }
 
  private renderFileStructure(items: any[], markdown: string[], depth: number): void {
    const indent = '  '.repeat(depth);
    
    items.forEach(item => {
      const icon = item.type === 'directory' ? 'ðŸ“' : 'ðŸ“„';
      const name = item.type === 'directory' ? `${item.name}/` : item.name;
      markdown.push(`${indent}${icon} ${name}`);
      
      if (item.children && item.children.length > 0) {
        this.renderFileStructure(item.children, markdown, depth + 1);
      }
    });
  }
}

// Export the main planner instance
export const planner = new Planner();

// Export types for use in extension
export * from './interfaces';